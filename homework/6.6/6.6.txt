6.6
https://github.com/netology-code/virt-homeworks/tree/master/06-db-06-troobleshooting

1.
	напишите список операций, которые вы будете производить для остановки запроса пользователя
	- посмотреть текущие операции можно используя запрос db.currentOp({"active" : true, "secs_running" : { "$gt" : 170 }})
	- остановить долгоиграющий запрос db.killOp(<opId>)
    предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB
	- можно ограничить время исполнения запроса добавив к нему .maxTimeMS(3000)
	- если возможно, то оптимизировать запрос для более быстрой обработки
	
2.
	Так как редис однопоточный, то возможно какойто запрос оказался слишком тяжелым, создав очередь выполнения и 
	при увеличении очереди произошло переполнение памяти, заблокировав дальнейшее создание записей.
	Для мониторинга и выявления подобных инцидентов можно временно использовать встроенный watchdog или slow log.

3.
	Очевидно что это сетевая проблема, возможно не хватает времени для передачи запроса, тогда следует увеличить 
	параметр connect_timeout или повысить net_read_timeout. Так же можно увеличить максимальный размер запроса
	max_allowed_packet.
	Для локазизации проблемы можно использовать лог запросов, чтобы выяснить на каком запросе произошла ошибка
	и по возможности его оптимизировать.
	
4.
	OutOfMemory killer убивает неиспользуемые процессы чтобы освободить память, но он так же может внезапно убить 
	процесс postgresql, что повлечет за собой потерю данных и непредвиденные ошибки.
	Чтобы избежать подобного нужно увеличить размер памяти на сервере или настроить postgres для более оптимальной работы
	с текущими ресурсами использую настройки shared_buffers, work_mem, уменьшить max_connections, временно 
	отключить autovacuum.
	Наблюдать можно через Pg_top, следить за запросами и потреблением ресурсов БД.